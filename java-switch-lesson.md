# Выражения Switch и сопоставление с образцом

Представь, что работаешь разработчиком в стартапе по доставке товаров, который активно развивается. Стартап уже привлек
внимание первых клиентов. Однако, как это часто бывает в быстро растущих компаниях, накопленный технический долг
начинает давать о себе знать.

На утреннем daily техлид рассказывает о проблеме: одна из ключевых частей приложения — модуль обработки заказов — стал
источником частых багов и снижения производительности.
Этот модуль, написанный несколько лет назад, буквально ломается под весом новых функциональных требований. В модуле есть
несколько типов доставки: стандартная, экспресс, международная и цифровая.
Открывая код, вы видите множество `switch-операторов`, которые выполняют разные задачи. Но проблема в том, что код
разбросан и трудно поддерживаем.
Вот пример одного из таких `switch-операторов`:

```java
public String gerNotification(String orderType) {
    if (orderType == null) {
        throw new IllegalArgumentException("Тип заказа не может быть null");
    }

    String notification;
    switch (orderType) {
        case "Standard":
            notification = "Стандартный заказ: обычная доставка.";
            break;
        case "Express":
            notification = "Экспресс заказ: быстрая доставка.";
            break;
        case "International":
            notification = "Международный заказ: доставка за границу.";
            break;
        case "Digital":
            notification = "Цифровой заказ: моментальная доставка.";
            break;
        default:
            notification = "Неизвестный тип заказа.";
            break;
    }

    return notification;
}
```

> В Java до версии 14 switch был оператором, который управлял выполнением блока кода в зависимости от значения
> выражения.

У такого подхода есть несколько недостатков:

- Много шаблонного кода: множество `case` и `break` делают код громоздким.
- Ошибки в поддержке: легко забыть добавить `break`, что приводит к ошибкам "проваливания" в следующий `case`.
- Необходимость проверки на null перед использованием оператора `switch`.
- Необходимость в объявлении переменной, которой будет присваиваться значение.
- Сложность в чтении и восприятии кода, особенно когда много веток.

К счастью, с выходом Java 14 и выше появился новый мощный инструмент — `switch-выражения`, который значительно упрощает
работу с кодом.

### Обрати внимание на несколько важных изменений:

- **Стрелочные функции (`->`):** Вместо того чтобы использовать `break`, просто пишешь стрелку `->`, и сразу после
  неё — результат, который нужно вернуть.
- **Возвращаемое значение:** `switch` теперь возвращает результат. Нет необходимости в дополнительной переменной для
  хранения результата внутри каждого case. Просто добавь `return` — и готово! :)

Вот как теперь будет выглядеть код выше с использованием новых возможностей Java:

```java
public String gerNotification(String orderType) {
    return switch (orderType) {
        case null -> throw new IllegalArgumentException("Тип заказа не может быть null");
        case "Standard" -> "Стандартный заказ: обычная доставка.";
        case "Express" -> "Экспресс заказ: быстрая доставка.";
        case "International" -> "Международный заказ: доставка за границу.";
        case "Digital" -> "Цифровой заказ: моментальная доставка.";
        default -> "Неизвестный тип заказа.";
    };
}
```

Результат значительно проще, круче и лаконичнее! Сокращаем код, а значит и количество багов. Теперь у нас больше времени на кофе (и
обсуждение мемов с коллегами!:)).

Давай попробуем закрепить знания, проведя рефакторинг следующего фрагмента кода:

```java
    public String getOrderStatusMessage(String status) {
    if (status == null) {
        throw new IllegalArgumentException("Статус заказа не может быть null");
    }

    String message;
    switch (status) {
        case "Pending":
            message = "Ваш заказ ожидает обработки.";
            break;
        case "Processing":
            message = "Ваш заказ в процессе обработки.";
            break;
        case "Shipped":
            message = "Ваш заказ отправлен.";
            break;
        case "Delivered":
            message = "Ваш заказ доставлен.";
            break;
        case "Cancelled":
            message = "Ваш заказ был отменён.";
            break;
        default:
            message = "Неизвестный статус заказа.";
            break;
    }

    return message;
}
```

Оптимизируй его, используя новые возможности `switch-выражений` и убедись, что код:

- Использует стрелочные функции (`->`) вместо `case` и `break`.
- Возвращает значение напрямую, без использования промежуточных переменных.
- Проверяет входные данные на null внутри switch.

Отлично! Представим, что в нашем модуле доставки есть объекты различных типов заказов, которые требуют сложной обработки
в зависимости от их типа. Например, нам нужно вычислить скидку на доставку для каждого типа заказа, учитывая специфику
бизнеса.
Допустим, что скидка для заказов на доставку еды зависит от суммы заказа, для одежды — от сезона, а для документов — от
срочности. Для цифровых товаров мы предоставляем фиксированную большую скидку.

```java
public double calculateDiscount(Delivery delivery) {
    if (delivery == null) {
        throw new IllegalArgumentException("Тип доставки не может быть null");
    }
    double discount;
    if (delivery instanceof FoodDelivery foodDelivery) {
        discount = foodDelivery.getOrderAmount() > 1000 ? 0.10 : 0.05;
    } else if (delivery instanceof ClothingDelivery clothingDelivery) {
        discount = clothingDelivery.isSeasonalDiscount() ? 0.15 : 0.10;
    } else if (delivery instanceof DocumentDelivery documentDelivery) {
        discount = documentDelivery.isUrgent() ? 0.20 : 0.15;
    } else if (delivery instanceof DigitalDelivery) {
        discount = 100.00;
    } else {
        discount = 0.0;
    }
    return discount;
}
```

Для таких операций идеально подходил бы switch, но ранее в силу ограниченности поддержки типов и сравнения только на
соответствие константному значению, приходилось использовать цепочку if-else.
Java 21 привнесла кучу интересных новинок, включая улучшения в switch:

- Возможность работы с любыми типами данных в switch.
- `pattern matching` в `case`, который позволяет проверять типы прямо в конструкции `switch`.
- Обработку значений null с помощью встроенного `case`.

Сопоставление с образцом или `pattern matching` можно представить как игру в угадывание с правилами. Представь, что у тебя
есть несколько коробок, и в каждой из них что-то лежит: в одной яблоки, в другой игрушки, в третьей книги. Ты не знаешь, что
именно в каждой коробке, но знаешь правила:

- Если коробка с яблоками — съешь одно.
- Если коробка с игрушками — поиграй.
- Если коробка с книгами — почитай.

Когда открываешь коробку, смотришь, что внутри, и действуешь по правилу, подходящему для этого содержимого.
Вот это и есть сопоставление с образцом в программировании: программа «открывает коробку», видит, что внутри (
определяет тип данных или объект), и выполняет соответствующие действия.

Теперь используя эти нововведения можем оптимизировать наш метод по расчету скидки на доставку:

```java
public double calculateDiscount(Delivery delivery) {
    return switch (delivery) {
        case null -> throw new IllegalArgumentException("Тип доставки не может быть null");
        case FoodDelivery fd -> fd.getOrderAmount() > 100 ? 0.10 : 0.05;
        case ClothingDelivery cd -> cd.isSeasonalDiscount() ? 0.15 : 0.10;
        case DocumentDelivery dd -> dd.isUrgent() ? 0.20 : 0.15;
        case DigitalDelivery dd -> 100.00;
        default -> 0.0;
    };
}
```

Теперь, когда мы узнали о нововведениях, давай попробуем оптимизировать метод `processDeliveryData`, который принимает объект типа
Object и возвращает информацию о том, как обработать этот объект, в зависимости от его типа и значения. Этот метод используется в
системе доставки для определения дальнейших действий с заказом. Текущая версия метода написана с использованием цепочки if-else:

```java
public String processDeliveryData(Object data) {
    if (data == null) {
        return "Данные отсутствуют";
    }
    if (data instanceof Integer weight) {
        return (weight > 50) ? "Требуется грузовой транспорт" : "Можно использовать стандартную доставку";
    } else if (data instanceof String address) {
        return address.isEmpty() ? "Адрес не указан" : "Доставка на адрес: " + address;
    } else if (data instanceof Boolean isExpress) {
        return isExpress ? "Экспресс-доставка" : "Стандартная доставка";
    } else if (data instanceof Double distance) {
        return (distance > 100) ? "Долгая доставка, требуется планирование" : "Стандартная доставка";
    } else {
        return "Неизвестный тип данных";
    }
}
```

Перепиши метод `processDeliveryData` с использованием switch и сопоставления с образцом, чтобы сделать его более
компактным и легко расширяемым:

- Integer: используется для веса заказа. Если вес больше 50 кг, необходимо использовать грузовой транспорт.
- String: представляет адрес доставки. Если строка пустая, возвращается сообщение о том, что адрес не указан.
- Boolean: указывает, требуется ли экспресс-доставка.
- Double: представляет расстояние доставки в километрах. Если расстояние превышает 100 км, требуется специальное
  планирование.
- Добавь корректную обработку значения null.
- Для неизвестных типов данных метод должен возвращать сообщение "Неизвестный тип данных".